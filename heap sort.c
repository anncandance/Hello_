//#include<stdio.h>
//#include<stdlib.h>
//#include<math.h>
//
//
//int *fit_tree(int* p, int n, int i){
//    int c;
//    int k;
//    k=i;                                                  // текущий индекс проблемного элемента
//    c=*(p+k);
//    while(((c<*(p+2*k+1))&&(2*k+1<n))||(((c<*(p+2*k+2))&&(2*k+2<n))))  //пока есть большие потомки
//        {if (2*k+2<n)
//            {if(c<*(p+2*k+1)&&(*(p+2*k+1)>=*(p+2*k+2)))   //есть второй потомок, меньший первого
//            {*(p+k) = *(p+2*k+1); *(p+2*k+1)=c; k=2*k+1;} // меняем местами с большим потомком, обновляем индекс
//             else if (c<*(p+2*k+2))                       //есть второй потомок, больший первого
//            {*(p+k) = *(p+2*k+2); *(p+2*k+2)=c; k=2*k+2;};}
//         else                                             // есть только 1 потомок
//         if (((c<*(p+2*k+1))&&(2*k+1<n)))
//            {*(p+k) = *(p+2*k+1); *(p+2*k+1)=c; k=2*k+1;};}
//
//    return p;
//}
//int main(){
//    int n, i, a, c, k;
//    int *p;
//    scanf("%d", &n);
//    p = (int*)(malloc(n*sizeof(int)));
//    for(i=0; i<n; i++) scanf("%d", (p+i));
//    // первый проход по массиву
//    for(i=(n-2)/2; i>=0; i--)  // не проверяем листья = n-2/2
//        {if (((*(p+i)< *(p+2*i+1))&&(2*i+1<n))||(*(p+i)<*(p+2*i+2)&&(2*i+2<n)))
//            {
//            fit_tree(p, n, i);};
//        }
//    //for(i=0; i<n; i++) printf("%d\n", *(p+i));
//    // заполняем массив
//    for(i=1; i<n; i++)  //
//    {c=*(p+n-i);*(p+n-i)=*p; *p=c;
//    fit_tree(p, n-i, 0);}
//    for(i=0; i<n; i++) printf("%d\n", *(p+i));
//
//}